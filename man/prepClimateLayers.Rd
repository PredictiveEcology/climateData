% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepClimateLayers.R
\name{prepClimateLayers}
\alias{prepClimateLayers}
\title{Prepare rasters for derived and 'as-is' climate variables}
\usage{
prepClimateLayers(
  climateVarsList,
  srcdir,
  dstdir,
  tile = NULL,
  future_years = NULL,
  future_period = NULL,
  historical_years = NULL,
  historical_period = NULL,
  gcm = NULL,
  ssp = NULL,
  cl = NULL,
  studyArea = NULL,
  studyAreaName = NULL,
  rasterToMatch = NULL,
  currentModuleName = "NoModule",
  ...
)
}
\arguments{
\item{climateVarsList}{Named list of lists, specifying the climate variables to extract and/or
calculate.
The name of each outer list element must be prefixed by either \code{future_} or \code{historical_},
and each inner list should consist of the following named elements:
\itemize{
\item \code{vars}: the raw variables used to derive the target variable;
\item \code{fun}: a quoted function used to derive the target variable,
where \code{quote(calcAsIs)} denotes target variables that ARE the raw variable:
\item \code{.dots}: additional arguments passed to \code{fun}.
}

See examples.}

\item{srcdir, dstdir}{character. vector of directory paths to source and destination raster files.}

\item{tile}{integer. tile id (e.g., the output of \code{tileID()}).}

\item{historical_years, future_years}{integer. consecutive data years to use (e.g., \code{2011:2100}).}

\item{historical_period, future_period}{character.
climate normal periods to use (e.g., \code{c("1951_1980", "1981_2010")}).}

\item{gcm}{character. name of GCM available in ClimateNA.}

\item{ssp}{integer. one of the available SSPs in ClimateNA (e.g., \code{370} or \code{585})}

\item{cl}{Optional cluster object.
If option \code{climateData.parallel.backend} is "parallel" (default), and \code{cl} is NULL (default),
a cluster will be created using up to \code{length(climVar)} number of CPU cores.
When using the "parallel" backend, users can pass their own \code{cl} object or specify option
\code{parallelly.availableCores.fallback} to control the number of cores used.
If \code{climateData.parallel.backend} is "future", \code{cl} is ignored, as the user is expected to
set up the future plan themselves (see \code{future::plan}).
Users may also need to specify setting up the cluster using 'sequential',
rather than the default 'parallel', via \code{parallelly.makeNodePSOCK.setup_strategy}.
See \code{?parallelly.options}.}

\item{studyArea}{an \code{sf} or \code{SpatVect} polygon delineating the boundaries of the study area.
typically used to crop/mask rasters when \code{rasterToMatch} is not supplied.
passed to \code{\link[reproducible:postProcessTo]{reproducible::postProcessTo()}}.}

\item{studyAreaName}{character string giving  the name of the study area.}

\item{rasterToMatch}{a \code{SpatRaster} object to use as the template for GIS operations.
passed to \code{\link[reproducible:postProcessTo]{reproducible::postProcessTo()}}.}

\item{currentModuleName}{character string giving the name of the current module.
used to tag \code{Cache} entries.}

\item{...}{additional arguments (not used)}
}
\description{
Prepare rasters for derived and 'as-is' climate variables
}
\examples{
if (require("archive", quietly = TRUE) &&
    require("googledrive", quietly = TRUE) &&
    require("SpaDES.tools", quietly = TRUE) &&
    !isTRUE(as.logical(Sys.getenv("CI", "false")))) {
  dPath <- file.path(tempdir(), "test_prepClimateLayers")
  climateType <- "historical"
  climatePath <- file.path(dPath, "climate") |> reproducible::checkPath(create = TRUE)
  climatePathOut <- file.path(climatePath, "outputs") |> reproducible::checkPath(create = TRUE)
  historical_prd <- c("1951_1980", "1981_2010")
  historical_yrs <- c(2011:2015)
  future_yrs <- c(2021:2025)
  GCM <- "CanESM5"
  SSP <- 370
  studyArea <- SpaDES.tools::randomStudyArea(size = 1e10)
  rasterToMatch <- terra::rast(studyArea, resolution = 250) |>
    terra::rasterize(studyArea, y = _)

  ## ATA mixes seasonal and normal variables; uses custom fun
  ## CMI uses yearly variable; no fun (as is)
  ## FFP uses yearly  variable; no fun (as is); similar name to bFFP and eFFP
  ## MDC uses monthly vars; uses custom fun
  climateVariables <- list(
    historical_ATA = list(
      vars = c("historical_MAT", "historical_MAT_normal"),
      fun = quote(calcATA),
      .dots = list(historical_period = historical_prd, historical_years = historical_yrs)
    ),
    future_ATA = list(
      vars = c("future_MAT", "historical_MAT_normal"),
      fun = quote(calcATA),
      .dots = list(historical_period = historical_prd, future_years = future_yrs)
    ),
    historical_CMI = list(
      vars = "historical_CMI",
      fun = quote(calcAsIs),
      .dots = list(historical_years = historical_yrs)
    ),
    historical_CMI_normal = list(
      vars = "historical_CMI_normal",
      fun = quote(calcCMInormal),
      .dots = list(historical_period = historical_prd, historical_years = historical_yrs)
    ),
    historical_FFP_normal = list(
      vars = "historical_FFP_normal", ## ensure FFP only; not bFFP nor eFFP
      fun = quote(calcAsIs),
      .dots = list(historical_period = historical_prd)
    ),
    future_FFP = list(
      vars = "future_FFP", ## ensure FFP only; not bFFP nor eFFP
      fun = quote(calcAsIs),
      .dots = list(future_years = future_yrs)
    ),
    historical_MDC = list(
      vars = c(sprintf("historical_PPT\%02d", 4:9), sprintf("historical_Tmax\%02d", 4:9)),
      fun = quote(calcMDC),
      .dots = list(historical_years = historical_yrs)
    ),
    future_CMD_sm = list(
      vars = "future_CMD_sm",
      fun = quote(calcAsIs),
      .dots = list(future_years = future_yrs)
    )
  )

  climateRasters <- prepClimateLayers(
    climateVarsList = climateVariables,
    srcdir = climatePath,    ## raw inputs, downloaded from Google Drive
    dstdir = climatePathOut, ## intermediate + final outputs
    historical_years = historical_yrs,
    future_years = future_yrs,
    historical_period = historical_prd,
    future_period = NULL,
    gcm = GCM,
    ssp = SSP,
    cl = NULL,
    studyArea = studyArea,
    studyAreaName = "my_study_area",
    rasterToMatch = rasterToMatch
  )
}
}
